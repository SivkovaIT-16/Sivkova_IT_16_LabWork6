# Сивкова Екатерина ИТ-16. Лабораторная работа №6. Вариант 2.

# Задание 1
Аннотации.

## Задача 1
### Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
- Целью может быть только МЕТОД
- Доступна во время исполнения программы
- Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные аннотацией @Invoke, и вызывает их автоматически.

### Алгоритм решения
Разработана аннотация @Invoke для маркировки методов, которые могут быть автоматически вызваны через механизм рефлексии.Данная аннотация применяется только к методам и служит маркером для указания, что метод должен быть доступен для автоматического вызова. Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация не имеет свойств

Для обработки аннотации @Invoke реализован класс InvokeReflection, использующий механизм рефлексии для анализа переданного объекта и автоматического вызова всех методов, помеченных данной аннотацией. Метод showInvoke() получает класс объекта, если переданный объект не null, перебирает все методы, объявленные в этом классе. Для каждого метода проверяется наличие аннотации @Invoke. Если аннотация присутствует, метод становится доступным для вызова через setAccessible (true) и выполняется с помощью Method.invoke. В случае возникновения исключений при вызове метода, они перехватываются и выводится соответствующее сообщение в консоль. Если переданный объект null метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Counter, который демонстрирует различные сценарии использования аннотации:
- Метод increment() помечен @Invoke - будет автоматически вызван
- Метод reset() помечен @Invoke - будет автоматически вызван
- Метод printCount() помечен @Invoke - будет автоматически вызван
- Метод add(int value) НЕ помечен @Invoke - не будет вызван автоматически
- Методы getCount() и setCount(int count) НЕ помечены @Invoke - не будут вызваны автоматически

В основной программе реализовано меню с четырьмя действиями:
1. Автоматический вызов всех методов с @Invoke: вызывает InvokeReflection.showInvoke(counter), который автоматически выполняет все аннотированные методы
2. Установить значение счётчика: позволяет вручную установить значение счётчика через метод setCount()
3. Добавить значение: позволяет увеличить счётчик на указанное значение через метод add() (не аннотированный)
4. Завершить программу

#### Тестирование
1. Введите номер действия:
- 0.Завершить программу.
- 1.Автоматически вызвать все методы с @Invoke.
- 2.Установить значение счётчика.
- 3.Добавить значение.
1
Счётчик сброшен на: 0
Счётчик увеличен до: 1
Текущее состояние счётчика: 1
Введите номер действия:
- 0.Завершить программу.
- 1.Автоматически вызвать все методы с @Invoke.
- 2.Установить значение счётчика.
- 3.Добавить значение.
- 2
- Введите значение для установки: 15
- Счётчик установлен на: 15
2. Введите номер действия:
- 0.Завершить программу.
- 1.Автоматически вызвать все методы с @Invoke.
- 2.Установить значение счётчика.
- 3.Добавить значение.
- 3
- Введите число для добавления: 2
- Счётчик увеличен на 2: 17
3. Введите номер действия:
- 0.Завершить программу.
- 1.Автоматически вызвать все методы с @Invoke.
- 2.Установить значение счётчика.
- 3.Добавить значение.
- 1
- Счётчик сброшен на: 0
- Счётчик увеличен до: 1
- Текущее состояние счётчика: 1
4. Введите номер действия:
- 0.Завершить программу.
- 1.Автоматически вызвать все методы с @Invoke.
- 2.Установить значение счётчика.
- 3.Добавить значение.
- 0
- Программа "Аннотация Invoke" завершена.

## Задача 2
### Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
- Целью может быть ТИП или ПОЛЕ
- Доступна во время исполнения программы
- Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.

### Алгоритм решения
Разработана аннотация @Default для указания класса по умолчанию. Данная аннотация может применятся к классам (указывает, какой класс следует считать классом по умолчанию для данного типа) и полям (указывает, какой класс должен использоваться как ззначение по умолчанию для этого поля). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Class<?> - принимает класс, который будет рассматриваться как класс по умолчанию.

Для обработки аннотации @Default реализован класс DefaultReflection, использующий механизм рефлексии для анализа переданного объекта. Метод showDefault() получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Default и, если она присутствует, выводит имя класса, указанного в свойстве value аннотации. Если переданный объект null или аннотация @Default отсутствует, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Cat помеченный аннотацией @Default c указанием класса Cat по умолчанию. 

В основной программе:
1. Создаётся объект Cat и выполняются его методы meow() и play()
2. Вызывается метод DefaultReflection.showDefault(cat) для демонстрации работы с аннотацией @Default
3. Создаётся объект Counter (класс без аннотации @Default)
4. Вызывается метод DefaultReflection.showDefault(counter) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
1. Класс Cat.
- Барсик говорит: Мяу-мяу!
- Барсик играет с мышкой!
- Класс по умолчанию: Cat

2. Класс Counter.
- Ошибка: Аннотация @Default не найдена.

## Задача 3
### Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
- Целью может быть ТИП или ПОЛЕ
- Доступна во время исполнения программы
- Имеет необязательное свойство value c двумя вариантами значений: YES или NO
- Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля, где @ToString имеет значение YES.

### Алгоритм решения
Разработана аннотация @ToString для управления включением классов и полей в строковое представление объектов. Данная аннотация может применятся к классам (определяет, должен ли весь класс участвовать в формировании строкового представления) и полям (контролирует, должно ли конкретное поле включаться в результат). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Mode - перечисления, содержащего два значения: YES (включить в строковое представление) и NO (исключить из строкового представления). По умолчанию установлено значение YES, поэтому явное указание требуется только для исключения элементов из вывода.

Для обработки аннотации @ToString реализован класс ToStringReflection, который использует механизм рефлексии для анализа объекта и формирования его строкового представления. Метод showToString() определяет класс объекта с помощью рефлексии, если переданный объект не null, получает список его полей и проверяет наличие анотации @ToString как на классе, так и на каждом поле. Далее формируется строка с помощью StringBuilder, в которую сначала добавляется имя класса, а потом значения всех полей, которые не помечены как Mode.NO. Для доступа к приватным полям используется метод setAccessible (true), что позволяет корректно получить их значения даже при ограниченной видимости (в случае возникновения IllegalAccessException при получении значения поля, метод выбрасывает RuntimeException). Если аннотация класса отсутствует или имеет значение Mode.YES, метод перебирает все поля, проверяет аннотацию каждого поля и добавляет имя поля и его значение в результирующую строку, поля, помеченные как Mode.NO, пропускаются. В результате формируется строковое представление объекта, которое включает только необходимые данные. Если переданный объект null или метод выводит строку "null" и завершает работу.

Для тестирования используется класс Dog, помеченный аннотацией @ToString без указания значения (используется значение по умолчанию YES). Поле age помечено аннотацией @ToString(Mode.NO), что исключает его из строкового представления. Остальные поля (name, breed, color) включаются в вывод, так как не имеют явных аннотаций исключения.

В основной программе:
1. Создаётся объект Dog и выполняется его метод bark()
2. Вызывается стандартный переопределённый метод toString() класса Dog
  - Формирование строки: "Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}"
  - Вывод в консоль: "Стандартный toString(): Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}"
4. Вызов аннотированного метода ToStringReflection.showToString(dog)
- Формирование финальной строки: "Dog { name = Шарик breed = Лабрадор color = Коричневый }"
- Вывод в консоль: "Аннотированный toString(): Dog { name = Шарик breed = Лабрадор color = Коричневый }"

#### Тестирование
- Шарик говорит: Гав-гав!
- Стандартный toString(): Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}
- Аннотированный toString(): Dog { name = Шарик breed = Лабрадор color = Коричневый  }

## Задача 4
### Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
- Целью может быть ТИП или АННОТАЦИЯ
- Доступна во время исполнения программы
- Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

### Алгоритм решения
Разработана аннотация @Validate для указания классов, которые должны участвовать в механизме валидации. Данная аннотация может применятся к классам (определяет набор классов, которые должны проверяться или использоваться в процессе валидации данного класса) и аннотациям (указывает, какие классы связаны с данной аннотацией в контексте валидации). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Class<?> - принимает массив классов. Свойство является обязательным, что гарантирует явное указание классов для валидации при использовании аннотации.

Для обработки аннотации @Validate реализован класс ValidateReflection, использующий механизм рефлексии для анализа переданного объекта и вывода информации о классах, указанных в аннотации. Метод showValidation() получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Validate. Если она присутствует, метод получает массив классов, указанных в свойстве value аннотации. Далее метод перебирает указанные классы и выводит их названия в консоль. Если переданный объект null, аннотация @Validate. отсутствует или полученный массив пустой, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Dog, помеченный аннотацией @Validate с указанием классав String и Integer (эти классы представляют типы данных, которые должны проверяться при валидации объектов класса Dog).

В основной программе:
1. Создаётся объект Dog и выполняется его метод bark()
2. Вызывается метод ValidateReflection.showValidation(dog) для демонстрации работы с аннотацией @Validate
3. Создаётся объект Cat (класс без аннотации @Validate) и выполняются его методы meow() и play()
4. Вызывается метод ValidateReflection.showValidation(cat) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
1. Класс Dog.
- Бобик говорит: Гав-гав!
- String
- Integer

2. Класс Cat.
- Мурзик говорит: Мяу-мяу!
- Мурзик играет с мышкой!
- Ошибка: Аннотация @Validate не найдена.

## Задача 5
### Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
- Целью может быть ТИП
- Доступна во время исполнения программы
- Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.

### Алгоритм решения
Разработана аннотация @Two для хранения двух значений: строкового и целочисленного. Данная аннотация применяется только к типам (классам) и служит для хранения пары связанных значений, которые могут быть использованы во время выполнения программы. Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация имеет два обязательных свойства: first типа String и second типа int. Оба свойства являются обязательными, что гарантирует явное указание значений при использовании аннотации.

Для обработки аннотации @Two реализован класс TwoReflection, использующий механизм рефлексии для анализа переданного объекта и вывода значений, указанных в аннотации. Метод showTwo() получает класс объекта, если переданный объект не null, получает аннотацию @Two, если она присутствует над классом. Далее метод извлекает из аннотации два значения — first (проверяет, что не null и не пустая строка) и second (проверяет, что не отрицательное) — и, при успешном прохождении проверок, выводит их в консоль. Если переданный объект null или значения, извлечённые из аннотации, не прошли проверку метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Cat помеченный аннотацией @Two, где значение first содержит имя кота "Снежок", а значение second содержит возраст кота 3

В основной программе:
1. Ввод данных пользователем:
- Запрос имени кота (с валидацией через Validator.checkString())
- Запрос возраста кота (с валидацией через Validator.checkInteger())
- Запрос цвета кота (с валидацией через Validator.checkString())
2. Создаётся объект Cat с введёнными пользователем параметрами
3. Вызывается метод TwoReflection.showTwo(cat) для вывода значений из аннотации

#### Тестирование
1. Введите имя кота: 4оа3л
- Ошибка. Строка должна состоять только из букв, пробелов, '-' или '.'.
- Введите новое значение: Барсик

2. Введите возраст кота: о34о
- Ошибка. Введено неверное число.
- Введите целое число: 2

3. Введите цвет кота: 9в1
- Ошибка. Строка должна состоять только из букв, пробелов, '-' или '.'.
- Введите новое значение: Чёрно-белый
- Создан кот: Кот Барсик, 2 года, цвет: Чёрно-белый

4. Снежок 3

## Задача 6
### Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
- Целью может быть ТИП
- Доступна во время исполнения программы
- Имеет необязательное свойство value, типа String[]
- Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что список пуст.

### Алгоритм решения
Разработана аннотация @Cache для указания областей кэширования, связанных с классом. Данная аннотация применяется только к типам (классам) и определяет набор имён кэшей или ключевых пространств, в рамках которых должен работать данный класс. Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает необязательным свойством value типа String[] - принимает массив строковых идентификаторов кэшей. Значение по умолчанию - пустой массив - позволяет использовать аннотацию без явного указания областей.

Для обработки аннотации @Cache реализован класс CacheReflection, использующий механизм рефлексии для анализа переданного объекта и вывода информации о кэшируемых областях. Метод showCache() получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Cache. Если она присутствует, метод извлекает список кэшируемых областей из свойства value аннотации и выводит имена всех указанных областей в консоль. Если переданный объект null, аннотация @Cache отсутствует или список кэшируемых областей пуст, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используются класс Fraction, помеченный аннотацией @Cache c указанием трёх областей кэширования: "numerator", "denominator", "doubleValues" и класс Counter, помеченный аннотацией @Cache без указания областей кэширования. 

В основной программе:
1. Создаётся объект Fraction с параметрами 3/4
2. Вызывается метод CacheReflection.showCache(fraction) для демонстрации работы с аннотацией @Cache
3. Создаётся объект Counter
4. Вызывается метод CacheReflection.showCache(counter) для демонстрации работы с аннотацией @Cache
5. Создаётся объект Cat (класс без аннотации @Cache)
6. Вызывается метод CacheReflection.showCache(cat) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
1. Класс Fraction.
- Кэшируемые области: [numerator, denominator, doubleValues]

2. Класс Counter.
- Ошибка: Список кэшируемых областей пуст.

3. Класс Cat.
- Ошибка: Аннотация @Cache не найдена.

# Задание 2
Тестирование.

## Задача 2
### Текст задачи
Создайте тест, используя фреймворк JUnit, который проверяет корректность вызова методов, отмеченных аннотацией @Invoke.
- Использовать Reflection API для поиска методов с аннотацией.
- Убедиться, что метод действительно выполняется без исключений.
- Проверить, что возвращаемое значение или побочный эффект соответствует ожиданиям (например, устанавливает флаг или изменяет состояние объекта).
- Тест должен использовать аннотацию @BeforeEach для подготовки тестируемого экземпляра класса.

### Алгоритм решения
Зазработан тестовый класс TestInvoke для проверки корректности работы с аннотацией @Invoke. Класс использует фреймворк JUnit для организации модульного тестирования. Тесты проверяют работу аннотации и обработки методов через Reflection API.

Перед выполнением каждого теста метод setUp(), помеченный аннотацией @BeforeEach, создаёт новый экземпляр класса Counter (некоторые методы класса помечены аннотацией @Invoke). Это предотвращает влияние одного теста на результаты другого.

Тест testFindMethodsWithInvokeAnnotation: Поиск методов с аннотацией @Invoke - проверяет, что Reflection API корректно находит все методы, помеченные аннотацией @Invoke. Сначала получает все методы класса Counter через getDeclaredMethods(), для каждого метода проверяет наличие аннотации @Invoke с помощью isAnnotationPresent(), если аннотация присутствует, увеличивает счётчик. Далее сравнивает количество найденных методов с аннотацией с ожидаемым количеством (3 метода). Если количество не совпадает - выбрасывает исключение AssertionError с описанием ошибки. При успешном прохождении теста - вывод соответствующего сообщения.

Тест testInvokeMethodsExecuteWithoutExceptions(): Выполнение методов без исключений - проверяет, что все методы с аннотацией @Invoke могут быть успешно вызваны через Reflection API без генерации исключений. Сначала получает все методы класса Counter через getDeclaredMethods(), для каждого метода проверяет наличие аннотации @Invoke с помощью isAnnotationPresent(). LДалее, если аннотация присутствует, вызывает метод через method.invoke(counter), перехватывает возможные исключения, если исключение возникло - выбрасывает AssertionError с описанием ошибки. Успешное выполнение теста означает, что все аннотированные методы выполнены без ошибок.

Тест testInvokeMethodsChangeObjectState(): Проверка изменения состояния объекта - проверяет, что методы с аннотацией @Invoke корректно изменяют состояние объекта и возвращают ожидаемые результаты. Сначала устанавливает начальное значение счётчика равное 5 и сохраняет его в переменную initialCount (начальное значение). Далее поочереди проверяет все методы класса Counter, помеченные аннотацией @Invoke: printCount() - вывод текущего значения счётчика, increment() - увеличение значения счётчика на 1, reset() - сброс значения счётчика на 0. Получает каждый из методов по имени через getMethod(), вызывает полученный метод через рефлексию и проверяет, что полученный результат соответствует ожидаемому.

#### Тестирование
1. Проверка вызова всех методов.
- Счётчик сброшен на: 0
- Счётчик увеличен до: 1
- Текущее состояние счётчика: 1
2. Поиск методов с аннотацией @Invoke выполнен корректно.
- Найдено 3 из 3 методов.
- Счётчик установлен на: 5
3. Проверка, что возвращаемые значения соответствуют ожиданиям.
- Текущее состояние счётчика: 5
- Счётчик увеличен до: 6
- Счётчик сброшен на: 0


## Задача 6
### Текст задачи
Разработайте тест, используя фреймворк JUnit, проверяющий корректность обработки аннотации @Two, если её свойства заданы некорректно. Например, строковое свойство first пустое (""), а числовое second отрицательное.
- Создайте вспомогательный класс с аннотацией @Two(first = "", second = -1).
- В тесте реализуйте метод, который через Reflection считывает значения аннотации.
- Если одно из свойств нарушает ожидаемые условия (first – пустая строка, second < 0), то должен быть выброшен IllegalArgumentException.
- Используйте assertThrows() из JUnit для проверки выбрасываемого исключения.

### Алгоритм решения

#### Тестирование
