# Сивкова Екатерина ИТ-16. Лабораторная работа №6. Вариант 2.

# Задание 1
Аннотации.

## Задача 1
### Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.

### Алгоритм решения

#### Тестирование

## Задача 2
### Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.

### Алгоритм решения
Разработана аннотация @Default для указания класса по умолчанию. Данная аннотация может применятся к классам (указывает, какой класс следует считать классом по умолчанию для данного типа) и полям (указывает, какой класс должен использоваться как ззначение по умолчанию для этого поля). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Class<?> - принимает класс, который будет рассматриваться как класс по умолчанию.

Для обработки аннотации @Default реализован класс DefaultReflection, использующий механизм рефлексии для анализа переданного объекта. Метод showDefault получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Default и, если она присутствует, выводит имя класса, указанного в свойстве value аннотации. Если переданный объект null или аннотация @Default отсутствует, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Cat помеченный аннотацией @Default c указанием класса Cat по умолчанию. 

В основной программе:
1. Создаётся объект Cat и выполняются его методы meow() и play()
2. Вызывается метод DefaultReflection.showDefault(cat) для демонстрации работы с аннотацией @Default
3. Создаётся объект Counter (класс без аннотации @Default)
4. Вызывается метод DefaultReflection.showDefault(counter) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
1. Класс Cat.
- Барсик говорит: Мяу-мяу!
- Барсик играет с мышкой!
- Класс по умолчанию: Cat

2. Класс Counter.
- Ошибка: Аннотация @Default не найдена.

## Задача 3
### Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство value c двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.

### Алгоритм решения
Разработана аннотация @ToString для управления включением классов и полей в строковое представление объектов. Данная аннотация может применятся к классам (определяет, должен ли весь класс участвовать в формировании строкового представления) и полям (контролирует, должно ли конкретное поле включаться в результат). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Mode - перечисления, содержащего два значения: YES (включить в строковое представление) и NO (исключить из строкового представления). По умолчанию установлено значение YES, поэтому явное указание требуется только для исключения элементов из вывода.

Для обработки аннотации @ToString реализован класс ToStringReflection, который использует механизм рефлексии для анализа объекта и формирования его строкового представления. Метод showDefault определяет класс объекта с помощью рефлексии, если переданный объект не null, получает список его полей и проверяет наличие анотации @ToString как на классе, так и на каждом поле. Далее формируется строка с помощью StringBuilder, в которую сначала добавляется имя класса, а потом значения всех полей, которые не помечены как Mode.NO. Для доступа к приватным полям используется метод setAccessible (true), что позволяет корректно получить их значения даже при ограниченной видимости. Если аннотация класса отсутствует или имеет значение Mode.YES, метод перебирает все поля, проверяет аннотацию каждого поля и добавляет имя поля и его значение в результирующую строку, поля, помеченные как Mode.NO, пропускаются. В результате формируется строковое представление объекта, которое включает только необходимые данные. Если переданный объект null или метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Dog, помеченный аннотацией @ToString без указания значения (используется значение по умолчанию YES). Поле age помечено аннотацией @ToString(Mode.NO), что исключает его из строкового представления. Остальные поля (name, breed, color) включаются в вывод, так как не имеют явных аннотаций исключения.

В основной программе:
1. Создаётся объект Dog и выполняется его метод bark()
2. Вызывается стандартный переопределённый метод toString() класса Dog
  - Формирование строки: "Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}"
  - Вывод в консоль: "Стандартный toString(): Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}"
4. Вызов аннотированного метода ToStringReflection.showToString(dog)
- Формирование финальной строки: "Dog { name = Шарик breed = Лабрадор color = Коричневый }"
- Вывод в консоль: "Аннотированный toString(): Dog { name = Шарик breed = Лабрадор color = Коричневый }"

#### Тестирование
- Шарик говорит: Гав-гав!
- Стандартный toString(): Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}
- Аннотированный toString(): Dog { name = Шарик breed = Лабрадор color = Коричневый  }

## Задача 4
### Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

### Алгоритм решения

#### Тестирование

## Задача 5
### Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.

### Алгоритм решения

#### Тестирование

## Задача 6
### Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.

### Алгоритм решения

#### Тестирование

# Задание 2
Тестирование.

## Задача 2
### Текст задачи
Создайте тест, используя фреймворк JUnit, который проверяет корректность вызова методов,
отмеченных аннотацией @Invoke.
• Использовать Reflection API для поиска методов с аннотацией.
• Убедиться, что метод действительно выполняется без исключений.
• Проверить, что возвращаемое значение или побочный эффект соответствует ожиданиям
(например, устанавливает флаг или изменяет состояние объекта).
• Тест должен использовать аннотацию @BeforeEach для подготовки тестируемого
экземпляра класса.

### Алгоритм решения

#### Тестирование

## Задача 6
### Текст задачи
Разработайте тест, используя фреймворк JUnit, проверяющий корректность обработки
аннотации @Two, если её свойства заданы некорректно. Например, строковое свойство first пустое
(""), а числовое second отрицательное.
• Создайте вспомогательный класс с аннотацией @Two(first = "", second = -1).
• В тесте реализуйте метод, который через Reflection считывает значения аннотации.
• Если одно из свойств нарушает ожидаемые условия (first – пустая строка, second < 0), то
должен быть выброшен IllegalArgumentException.
• Используйте assertThrows() из JUnit для проверки выбрасываемого исключения.

### Алгоритм решения

#### Тестирование
