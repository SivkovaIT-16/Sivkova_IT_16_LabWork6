# Сивкова Екатерина ИТ-16. Лабораторная работа №6. Вариант 2.

# Задание 1
Аннотации.

## Задача 1
### Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
- Целью может быть только МЕТОД
- Доступна во время исполнения программы
- Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные аннотацией @Invoke, и вызывает их автоматически.

### Алгоритм решения

#### Тестирование

## Задача 2
### Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
- Целью может быть ТИП или ПОЛЕ
- Доступна во время исполнения программы
- Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.

### Алгоритм решения
Разработана аннотация @Default для указания класса по умолчанию. Данная аннотация может применятся к классам (указывает, какой класс следует считать классом по умолчанию для данного типа) и полям (указывает, какой класс должен использоваться как ззначение по умолчанию для этого поля). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Class<?> - принимает класс, который будет рассматриваться как класс по умолчанию.

Для обработки аннотации @Default реализован класс DefaultReflection, использующий механизм рефлексии для анализа переданного объекта. Метод showDefault() получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Default и, если она присутствует, выводит имя класса, указанного в свойстве value аннотации. Если переданный объект null или аннотация @Default отсутствует, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Cat помеченный аннотацией @Default c указанием класса Cat по умолчанию. 

В основной программе:
1. Создаётся объект Cat и выполняются его методы meow() и play()
2. Вызывается метод DefaultReflection.showDefault(cat) для демонстрации работы с аннотацией @Default
3. Создаётся объект Counter (класс без аннотации @Default)
4. Вызывается метод DefaultReflection.showDefault(counter) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
1. Класс Cat.
- Барсик говорит: Мяу-мяу!
- Барсик играет с мышкой!
- Класс по умолчанию: Cat

2. Класс Counter.
- Ошибка: Аннотация @Default не найдена.

## Задача 3
### Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
- Целью может быть ТИП или ПОЛЕ
- Доступна во время исполнения программы
- Имеет необязательное свойство value c двумя вариантами значений: YES или NO
- Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля, где @ToString имеет значение YES.

### Алгоритм решения
Разработана аннотация @ToString для управления включением классов и полей в строковое представление объектов. Данная аннотация может применятся к классам (определяет, должен ли весь класс участвовать в формировании строкового представления) и полям (контролирует, должно ли конкретное поле включаться в результат). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Mode - перечисления, содержащего два значения: YES (включить в строковое представление) и NO (исключить из строкового представления). По умолчанию установлено значение YES, поэтому явное указание требуется только для исключения элементов из вывода.

Для обработки аннотации @ToString реализован класс ToStringReflection, который использует механизм рефлексии для анализа объекта и формирования его строкового представления. Метод showToString() определяет класс объекта с помощью рефлексии, если переданный объект не null, получает список его полей и проверяет наличие анотации @ToString как на классе, так и на каждом поле. Далее формируется строка с помощью StringBuilder, в которую сначала добавляется имя класса, а потом значения всех полей, которые не помечены как Mode.NO. Для доступа к приватным полям используется метод setAccessible (true), что позволяет корректно получить их значения даже при ограниченной видимости (в случае возникновения IllegalAccessException при получении значения поля, метод выбрасывает RuntimeException). Если аннотация класса отсутствует или имеет значение Mode.YES, метод перебирает все поля, проверяет аннотацию каждого поля и добавляет имя поля и его значение в результирующую строку, поля, помеченные как Mode.NO, пропускаются. В результате формируется строковое представление объекта, которое включает только необходимые данные. Если переданный объект null или метод выводит строку "null" и завершает работу.

Для тестирования используется класс Dog, помеченный аннотацией @ToString без указания значения (используется значение по умолчанию YES). Поле age помечено аннотацией @ToString(Mode.NO), что исключает его из строкового представления. Остальные поля (name, breed, color) включаются в вывод, так как не имеют явных аннотаций исключения.

В основной программе:
1. Создаётся объект Dog и выполняется его метод bark()
2. Вызывается стандартный переопределённый метод toString() класса Dog
  - Формирование строки: "Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}"
  - Вывод в консоль: "Стандартный toString(): Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}"
4. Вызов аннотированного метода ToStringReflection.showToString(dog)
- Формирование финальной строки: "Dog { name = Шарик breed = Лабрадор color = Коричневый }"
- Вывод в консоль: "Аннотированный toString(): Dog { name = Шарик breed = Лабрадор color = Коричневый }"

#### Тестирование
- Шарик говорит: Гав-гав!
- Стандартный toString(): Собака {Имя = 'Шарик', Порода = 'Лабрадор', Возраст = 8 лет, Цвет = 'Коричневый'}
- Аннотированный toString(): Dog { name = Шарик breed = Лабрадор color = Коричневый  }

## Задача 4
### Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
- Целью может быть ТИП или АННОТАЦИЯ
- Доступна во время исполнения программы
- Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

### Алгоритм решения
Разработана аннотация @Validate для указания классов, которые должны участвовать в механизме валидации. Данная аннотация может применятся к классам (определяет набор классов, которые должны проверяться или использоваться в процессе валидации данного класса) и аннотациям (указывает, какие классы связаны с данной аннотацией в контексте валидации). Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает одним свойством value типа Class<?> - принимает массив классов. Свойство является обязательным, что гарантирует явное указание классов для валидации при использовании аннотации.

Для обработки аннотации @Validate реализован класс ValidateReflection, использующий механизм рефлексии для анализа переданного объекта и вывода информации о классах, указанных в аннотации. Метод showValidation() получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Validate. Если она присутствует, метод получает массив классов, указанных в свойстве value аннотации. Далее метод перебирает указанные классы и выводит их названия в консоль. Если переданный объект null, аннотация @Validate. отсутствует или полученный массив пустой, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используется класс Dog, помеченный аннотацией @Validate с указанием классав String и Integer (эти классы представляют типы данных, которые должны проверяться при валидации объектов класса Dog).

В основной программе:
1. Создаётся объект Dog и выполняется его метод bark()
2. Вызывается метод ValidateReflection.showValidation(dog) для демонстрации работы с аннотацией @Validate
3. Создаётся объект Cat (класс без аннотации @Validate) и выполняются его методы meow() и play()
4. Вызывается метод ValidateReflection.showValidation(cat) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
1. Класс Dog.
- Бобик говорит: Гав-гав!
- String
- Integer

2. Класс Cat.
- Мурзик говорит: Мяу-мяу!
- Мурзик играет с мышкой!
- Ошибка: Аннотация @Validate не найдена.

## Задача 5
### Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
- Целью может быть ТИП
- Доступна во время исполнения программы
- Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.

### Алгоритм решения

#### Тестирование

## Задача 6
### Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
- Целью может быть ТИП
- Доступна во время исполнения программы
- Имеет необязательное свойство value, типа String[]
- Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что список пуст.

### Алгоритм решения
Разработана аннотация @Cache для указания областей кэширования, связанных с классом. Данная аннотация применяется только к типам (классам) и определяет набор имён кэшей или ключевых пространств, в рамках которых должен работать данный класс. Аннотация доступна во время выполнения программы (RUNTIME), что означает, что информация о ней может быть получена через механизм рефлексии Java во время работы программы. Аннотация обладает необязательным свойством value типа String[] - принимает массив строковых идентификаторов кэшей. Значение по умолчанию - пустой массив - позволяет использовать аннотацию без явного указания областей.

Для обработки аннотации @Cache реализован класс CacheReflection, использующий механизм рефлексии для анализа переданного объекта и вывода информации о кэшируемых областях. Метод showCache() получает класс объекта, если переданный объект не null, проверяет наличие над ним аннотации @Cache. Если она присутствует, метод извлекает список кэшируемых областей из свойства value аннотации и выводит имена всех указанных областей в консоль. Если переданный объект null, аннотация @Cache отсутствует или список кэшируемых областей пуст, метод выбрасывает исключение IllegalArgumentException с соответствующим сообщением.

Для тестирования используются класс Fraction, помеченный аннотацией @Cache c указанием трёх областей кэширования: "numerator", "denominator", "doubleValues" и класс Counter, помеченный аннотацией @Cache без указания областей кэширования. 

В основной программе:
1. Создаётся объект Fraction с параметрами 3/4
2. Вызывается метод CacheReflection.showCache(fraction) для демонстрации работы с аннотацией @Cache
3. Создаётся объект Counter
4. Вызывается метод CacheReflection.showCache(counter) для демонстрации работы с аннотацией @Cache
5. Создаётся объект Cat (класс без аннотации @Cache)
6. Вызывается метод CacheReflection.showCache(cat) для демонстрации обработки случая отсутствия аннотации

#### Тестирование
Класс Fraction.
Кэшируемые области: [numerator, denominator, doubleValues]

Класс Counter.
Ошибка: Список кэшируемых областей пуст.

Класс Cat.
Ошибка: Аннотация @Cache не найдена.

# Задание 2
Тестирование.

## Задача 2
### Текст задачи
Создайте тест, используя фреймворк JUnit, который проверяет корректность вызова методов, отмеченных аннотацией @Invoke.
- Использовать Reflection API для поиска методов с аннотацией.
- Убедиться, что метод действительно выполняется без исключений.
- Проверить, что возвращаемое значение или побочный эффект соответствует ожиданиям (например, устанавливает флаг или изменяет состояние объекта).
- Тест должен использовать аннотацию @BeforeEach для подготовки тестируемого экземпляра класса.

### Алгоритм решения

#### Тестирование

## Задача 6
### Текст задачи
Разработайте тест, используя фреймворк JUnit, проверяющий корректность обработки аннотации @Two, если её свойства заданы некорректно. Например, строковое свойство first пустое (""), а числовое second отрицательное.
- Создайте вспомогательный класс с аннотацией @Two(first = "", second = -1).
- В тесте реализуйте метод, который через Reflection считывает значения аннотации.
- Если одно из свойств нарушает ожидаемые условия (first – пустая строка, second < 0), то должен быть выброшен IllegalArgumentException.
- Используйте assertThrows() из JUnit для проверки выбрасываемого исключения.

### Алгоритм решения

#### Тестирование
